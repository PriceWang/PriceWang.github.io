<script src="assets/js/main.min.js"></script>

<script>
(function(){
  // add hover capability classes on <body> for robust control
  function updateHoverClass(){
    try{
      var mqHover = window.matchMedia && window.matchMedia('(hover: hover) and (pointer: fine)').matches;
      var touchCap = (navigator.maxTouchPoints||0) > 0 || 'ontouchstart' in window;
      var coarse = window.matchMedia && window.matchMedia('(pointer: coarse)').matches;
      var wideEnough = (window.innerWidth||0) >= 768;

      // UA heuristics: deny-list common mobile browsers that sometimes misreport hover
      var ua = (navigator.userAgent||'').toLowerCase();
      var isIOS = /iphone|ipod|ipad/.test(ua) || (navigator.platform === 'MacIntel' && (navigator.maxTouchPoints||0) > 1);
      var isAndroid = /android/.test(ua);
      var isWeChat = /micromessenger/.test(ua);
      var isQQ = /qqbrowser/.test(ua);
      var isUC = /ucbrowser/.test(ua);
      var isBaidu = /baidubrowser|baiduwap/.test(ua);
      var isSogou = /sogoumobilebrowser/.test(ua);
      var isMiui = /miuibrowser/.test(ua);
      var isHuawei = /huaweibrowser/.test(ua);
      var isVivo = /vivobrowser/.test(ua);
      var isOppo = /oppobrowser/.test(ua);
      var mobileDeny = isIOS || isAndroid && (isWeChat || isQQ || isUC || isBaidu || isSogou || isMiui || isHuawei || isVivo || isOppo);

      // manual override via localStorage: set 'hoverMode' to 'force-on' or 'force-off'
      var override = undefined;
      try{ override = localStorage.getItem('hoverMode'); }catch(e){}

      // hard stop on smaller screens regardless of MQ quirks
      var hardSizeStop = (window.innerWidth||0) < 1024;

      var canHover = mqHover && !touchCap && !coarse && wideEnough && !mobileDeny && !hardSizeStop;
      if (override === 'force-on') canHover = true;
      if (override === 'force-off') canHover = false;
      document.body.classList.remove('can-hover','no-hover');
      document.body.classList.add(canHover ? 'can-hover' : 'no-hover');
    }catch(e){}
  }
  updateHoverClass();
  window.addEventListener('resize', function(){
    // debounce
    clearTimeout(window.__hoverResizeTimer);
    window.__hoverResizeTimer = setTimeout(updateHoverClass, 150);
  });

  function initLife(){
    const canvas = document.getElementById('tic-tac-toe-canvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const DPR = Math.min(window.devicePixelRatio||1, 2);

    let cell=0, size=0, originX=0, originY=0;
    const board = Array(9).fill(null); // null | 'X' | 'O'
    let over=false, winCells=null;

    function fit(){
      const w = Math.floor(canvas.clientWidth || 240);
      const h = Math.floor(canvas.clientHeight || w);
      canvas.width  = w * DPR;
      canvas.height = h * DPR;
      ctx.setTransform(DPR,0,0,DPR,0,0);

      cell = Math.floor(Math.min(w,h) / 3);
      size = cell * 3;
      originX = Math.floor((w - size) / 2);
      originY = Math.floor((h - size) / 2);
      draw();
    }

    function reset(){
      for (let i=0;i<9;i++) board[i]=null;
      over=false; winCells=null; draw();
    }

    function draw(){
      const vw = canvas.width / DPR, vh = canvas.height / DPR;
      ctx.clearRect(0,0,vw,vh);
      ctx.fillStyle = '#fff';
      ctx.fillRect(0,0,vw,vh);

      ctx.save();
      ctx.translate(originX, originY);

      ctx.strokeStyle = '#E8ECF1';
      ctx.lineWidth = Math.max(1, Math.round(cell*0.06));
      for(let i=1;i<3;i++){
        ctx.beginPath(); ctx.moveTo(i*cell, 0);     ctx.lineTo(i*cell, 3*cell); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0,     i*cell); ctx.lineTo(3*cell, i*cell); ctx.stroke();
      }

      const lw = Math.max(2, Math.round(cell*0.12));
      const pad = Math.round(cell*0.24);
      ctx.lineCap='round'; ctx.lineJoin='round';
      ctx.strokeStyle = '#111';
      ctx.lineWidth = lw;
      for(let k=0;k<9;k++){
        const m = board[k]; if(!m) continue;
        const r = (k/3)|0, c = k%3;
        const x = c*cell, y = r*cell;
        if(m==='X'){
          ctx.beginPath(); ctx.moveTo(x+pad, y+pad); ctx.lineTo(x+cell-pad, y+cell-pad); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(x+cell-pad, y+pad); ctx.lineTo(x+pad, y+cell-pad); ctx.stroke();
        }else{
          ctx.beginPath(); ctx.arc(x+cell/2, y+cell/2, (cell/2 - pad), 0, Math.PI*2); ctx.stroke();
        }
      }

      if (winCells && winCells.length === 3) {
        const WIN = '#ff4d4f';
        const t = Math.max(4, cell * 0.16);
        const edgePad = Math.max(6, cell * 0.18);

        const [a,,c] = winCells;
        const ra = (a/3)|0, ca = a%3;
        const rc = (c/3)|0, cc = c%3;

        ctx.strokeStyle = WIN;
        ctx.lineWidth = t;
        ctx.lineCap = 'round';

        ctx.beginPath();
        if (ra === rc) {
          const y = ra*cell + cell/2;
          ctx.moveTo(edgePad, y);
          ctx.lineTo(3*cell - edgePad, y);
        } else if (ca === cc) {
          const x = ca*cell + cell/2;
          ctx.moveTo(x, edgePad);
          ctx.lineTo(x, 3*cell - edgePad);
        } else if (a===0 && c===8) {
          ctx.moveTo(edgePad, edgePad);
          ctx.lineTo(3*cell - edgePad, 3*cell - edgePad);
        } else {
          ctx.moveTo(3*cell - edgePad, edgePad);
          ctx.lineTo(edgePad, 3*cell - edgePad);
        }
        ctx.stroke();
      }

      ctx.restore();
    }

    const LINES = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
    function winningLine(b){
      for(const line of LINES){
        const [a,b2,c] = line;
        if(b[a] && b[a]===b[b2] && b[a]===b[c]) return line;
      }
      return null;
    }
    function result(b){
      const line = winningLine(b);
      if (line) return b[line[0]];
      if (b.every(Boolean)) return 'draw';
      return null;
    }

    function minimax(b, isMax){
      const r = result(b);
      if(r==='O') return  1;
      if(r==='X') return -1;
      if(r==='draw') return 0;
      if(isMax){
        let best=-2;
        for(let i=0;i<9;i++) if(!b[i]){ b[i]='O'; best=Math.max(best, minimax(b,false)); b[i]=null; if(best===1) break; }
        return best;
      }else{
        let best= 2;
        for(let i=0;i<9;i++) if(!b[i]){ b[i]='X'; best=Math.min(best, minimax(b,true));  b[i]=null; if(best===-1) break; }
        return best;
      }
    }
    function bestMove(b){
      let mv=null, best=-2;
      for(let i=0;i<9;i++) if(!b[i]){ b[i]='O'; const s=minimax(b,false); b[i]=null; if(s>best){best=s; mv=i;} }
      return mv;
    }

    function cellAt(e){
      const rect = canvas.getBoundingClientRect();
      const px = e.clientX - rect.left, py = e.clientY - rect.top;
      const x = px - originX, y = py - originY;
      if(x<0||y<0||x>=size||y>=size) return -1;
      const c = (x/cell)|0, r = (y/cell)|0;
      return r*3 + c;
    }

    function onPointerDown(e){
      if(over) return;
      const idx = cellAt(e); if(idx<0 || board[idx]) return;
      board[idx]='X'; draw();
      let r = result(board);
      if(r){
        over=true;
        winCells = (r==='draw') ? null : winningLine(board);
        draw();
        return;
      }
      const mv = bestMove(board);
      if(mv!=null){ board[mv]='O'; draw(); }
      r = result(board);
      if(r){
        over=true;
        winCells = (r==='draw') ? null : winningLine(board);
        draw();
      }
    }

    canvas.addEventListener('pointerdown', onPointerDown);
    (canvas.parentElement||canvas).addEventListener('pointerleave', reset);

    const ro = new ResizeObserver(fit); ro.observe(canvas);
    fit();
  }

  (function(){
    const start = () => setTimeout(initLife, 0);
    if (document.readyState === 'complete' || document.readyState === 'interactive') start();
    else window.addEventListener('DOMContentLoaded', start);
  })();
})();
</script>

{% include analytics.html %}
{% include fetch_google_scholar_stats.html %}


